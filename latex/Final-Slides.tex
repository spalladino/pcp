\documentclass{beamer}
%\usepackage[spanish]{babel}
\usepackage[ansinew]{inputenc}
\usepackage{amsmath}
\usepackage{enumerate}
\usepackage{exscale}
\usepackage{indentfirst}
\usepackage{latexsym}
\usepackage{proof}

\usetheme{warsaw}


%\newcommand{\Re}{\mathcal{R}}
\newcommand{\Q}{\mathcal{Q}}

\begin{document}

\title{Solving Linear Constraints}
\author{Santiago Palladino}
\date{Diciembre 2009}

\begin{frame}
\titlepage
\end{frame}

\begin{frame}
\frametitle{Índice}
\tableofcontents
\end{frame} 

\setlength{\parskip}{10pt plus 1pt minus 1pt}

\section{Lineal continuo}
\subsection{Sistemas de ecuaciones}

\begin{frame}
\frametitle{Sistemas de ecuaciones lineales}

Dado un conjunto de $n$ incógnitas y $m$ ecuaciones en $\Re$, se desea encontrar una solución para dicho sistema.

\begin{itemize}
\item $x_i$ incógnitas
\item $a_{ij}$ coeficientes
\item $b_{j}$ términos independientes
\end{itemize}

Se busca resolver el sistema $Ax = b$.

\end{frame} 

\begin{frame}
\frametitle{Soluciones de sistemas lineales}

Un sistema de ecuaciones lineales puede resultar:
\begin{itemize}
\item Compatible determinado: solución única ($rg(A) = n$)
\item Compatible indeterminado: infinitas soluciones ($rg(A) < n$)
\item Incompatible: sin solución ($b \notin \textsc{Im}(A)$)
\end{itemize}

\end{frame}

\begin{frame}
\frametitle{Sistemas equivalentes}

Dos sistemas son equivalentes si admiten el mismo conjunto de soluciones.

Existen distintas operaciones que pueden realizarse sobre $A$ y $b$ en simultáneo para generar sistemas equivalentes. 

Estas operaciones se basan en eliminar ecuaciones linealmente dependientes o generar nuevas a partir de combinaciones de las existentes.

\end{frame}


\begin{frame}
\frametitle{Resolución de sistemas lineales}

Resolver sistemas de ecuaciones lineales en $\Re$ es un problema bien resuelto y tiene complejidad polinomial $O(n^3)$. Hasta ahora la mejor marca está en $O(n^{2.376})$.

El algoritmo más conocido para resolver este problema es el de \textit{Eliminación Gaussiana}, el cual genera un sistema equivalente triangular superior que resuelve usando back substitution.

Limitándose a $\Q$ se puede salvar cualquier problema generado por el uso de aritmética finita y representar los valores sin pérdida de información.

\end{frame} 

\subsection{Sistemas de inecuaciones}
\begin{frame}
\frametitle{Sistemas de inecuaciones lineales}

Los sistemas de inecuaciones lineales se representan como $Ax \leq b$ con $x \geq 0$. 

Se puede construir una equivalencia entre:
\begin{enumerate}
\item $Ax \leq b, \ x \geq 0$
\item $Ax \geq b, \ x \geq 0$ 
\item $Ax = b, \ x \geq 0$ 
\end{enumerate}

En este caso no se busca una solución en particular sino que se tiene un poliedro que determina una región factible.

\end{frame} 

\begin{frame}
\frametitle{Interpretación geométrica}

Las restricciones lineales definen un poliedro en $\Re^n$. Notar que dicho poliedro puede ser o no acotado.

Dependiendo de cuántas igualdades se usen en la descripción del poliedro se determina la \textit{dimensión} del mismo.

A partir de esto se definen las \textit{facetas} del poliedro como caras cuya dimensión es una menos que la del poliedro.

Vale que si el poliedro es acotado (politopo) entonces todo punto del poliedro puede expresarse como una combinación convexa de sus extremos.

\end{frame}

\subsection{Programación lineal}
\begin{frame}
\frametitle{Optimización}

Generalmente se desea ubicar el punto que maximiza o minimiza una determinada función objetivo $c$ dentro de la región factible determinada por el poliedro.

Esto se lo conoce como un \textit{problema de programación lineal}

\[
\begin{array}{rl}
max & cx \\
s.t. & Ax \leq b \\
& x \in \Re^{\geq 0}
\end{array}
\]

\end{frame} 

\begin{frame}
\frametitle{Ejemplo: Problema de la dieta}

Se tienen $n$ alimentos con los que se debe formar una dieta diaria para cubrir $m$ nutrientes necesarios. Cada alimento $i$ aporta una cantidad $a_{ij}$ del nutriente $j$, y se debe cubrir al menos $b_j$ de dicho nutriente, minimizando el costo total de la dieta.

\begin{itemize}
\item $a_{ij} \in A$ nutriente $j$ aportado por unidad de alimento $i$
\item $b_{j} \in b$ demanda del alimento $j$
\item $c_{i} \in c$ costo por unidad del alimento $i$
\item $x_{i} \in x$ cantidad del alimento $i$ a consumir
\end{itemize}

\end{frame} 

\begin{frame}
\frametitle{Resolución}

Los siguientes problemas se pueden resolver en tiempo polinomial para variables continuas:

\begin{enumerate}
\item Decidir si $Ax \leq b$ tiene solución $x$ y hallar una en caso afirmativo.
\item Decidir si $Ax = b$ tiene solución $x \geq 0$ y hallar una en caso afirmativo.
\item Decidir si $\max cx$ sujeto a $Ax \leq b$ es factible, infactible o no acotado, y hallar una solución factible u óptima según corresponda.
\end{enumerate}

\end{frame} 

\subsection{Métodos de resolución}
\begin{frame}
\frametitle{Métodos}

Los siguientes son algunos de los métodos más conocidos para resolución de problemas de programación lineal:

\begin{enumerate}
\item Simplex
\item Elipsoide
\item Punto interior
\item Fourier-Motzkin elimination
\item Sustitución de test points
\end{enumerate}

\end{frame} 

\begin{frame}
\frametitle{Simplex}

Para aplicar simplex deben primero reescribirse todas las desigualdades como igualdades agregando slacks y el funcional como maximización.

Las variables $x$ se separan en básicas ($x_B \geq 0$) y no básicas ($x_N = 0$). La cantidad de variables básicas es igual a la cantidad de restricciones.

\end{frame} 

\begin{frame}
\frametitle{Simplex por Diccionarios}

Se busca escribir las variables básicas y el funcional en función de las no básicas:
\[
\begin{array}{rl}
x_{B_j} &= d_j - f_j(x_N) \\
& \vdots \\
z &= z^* + g(x_N)
\end{array}
\]

El valor $z^*$ es el de la función objetivo en esa iteración. Si alguna de las variables de $x_N$ aparece con signo positivo en el funcional, es un candidato para entrar a la base, esto es, tomar un valor mayor a cero e iterar incrementar el objetivo.

\end{frame} 

\begin{frame}
\frametitle{Inicialización en Simplex}

Simplex requiere una solución inicial para ejecutar. Hallar esta solución equivale a determinar factibilidad del sistema $Ax \leq b$.

Para esto se crea un nuevo sistema añadiendo una variable artificial $a_j$ con coeficiente igual a $b_j$ a cada una de las restricciones. La solución $a_j = 1, x_i = 0$ resulta válida para el nuevo sistema.

Sobre este sistema se aplica Simplex con el objetivo de minimizar la suma de los $a_j$. Si este mínimo es $0$, los $x_i$ resultantes son una solución válida del problema original. De lo contrario, el original es infactible.

\end{frame} 

\begin{frame}
\frametitle{Simplex Dual}

El dual de $\max cx$ sujeto a $Ax \leq b$ se define como $\min by$ sujeto a $yA = c$.

En caso de tener solución, los óptimos de ambos problemas coinciden. Una perturbación en el diccionario óptimo rompe factibilidad en uno de los problemas y optimalidad en el dual.

Simplex dual es una variación de simplex en la que se resuelven en paralelo un problema y su dual aplicando operaciones equivalentes. Esto permite resolver muy eficientemente modificaciones al sistema original dado su óptimo.

\end{frame}

\begin{frame}
\frametitle{Métodos de Punto Interior}

Dado el poliedro generado por el sistema, simplex recorre en cada iteración un punto extremo del mismo buscando el óptimo. Notar que en peor caso puede recorrerlos todos con lo que resulta exponencial.

Los métodos de punto interior comienzan por un punto interior al poliedro y siguen un camino de acuerdo a una cierta estrategia hasta llegar a la frontera. El punto en el que alcanzan la frontera es el óptimo.

\end{frame} 

\begin{frame}
\frametitle{Fourier-Motzkin Elimination}

El método de Fourier-Motzkin consiste en eliminar iterativamente cada variable del sistema, obteniendo en cada paso un sistema equivalente. El sistema obtenido finalmente está compuesto sólo por constantes, con lo que es trivial verificar su factibilidad.

Esto puede utilizarse para eliminar cuantificadores en fórmulas de $T_{lin}$, donde $T_{lin}$ es la teoría de primer orden de los reales sobre los racionales.

Substitution of test points puede verse como una optimización de Fourier-Motzkin. En peor caso, este problema resulta doblemente exponencial.

\end{frame} 

\section{Lineal entero}
\subsection{Programación lineal entera}

\begin{frame}
\frametitle{Variables enteras}

Un sistema $Ax = b$ en el que $A$ y $b$ tienen coeficientes racionales y se restringe a que $x \in \mathcal{Z}^n$ puede resolverse de forma polinomial.

Los casos interesantes $Ax \leq b$ con $x \in \mathcal{Z}^n$ o $Ax = b$ con $x \in \mathcal{N}^n$ resultan NP-Completos.

La demostración de que el problema es NP se basa en resolver SAT mediante la búsqueda de una solución factible para un problema de programación lineal entera binario.

\end{frame}

\begin{frame}
\frametitle{SAT como 0-1 ILP}

Sea la fórmula proposicional a determinar factibilidad:
\[
\phi = \bigwedge _{i=1}^k p_{i1} \vee \ldots \vee p_{in_i} \vee \neg q_{i1} \vee \ldots \vee \neg q_{im_i}
\]

Definiendo las variables binarias $p_{ij}, q_{ij}$, determinar satisfabilidad equivale a encontrar una solución factible al sistema determinado por las $k$ restricciones:
\[
p_{i1} + \ldots + p_{in_i} + (1- q_{i1}) + \ldots + (1- q_{im_i}) \geq 1, \ \ i = 1 \ldots k
\]

\end{frame}

\begin{frame}
\frametitle{Predicando sobre restricciones}

Es posible predicar sobre que una restricción se verifique añadiendo variables de decisión $y_j$:
\[
3x_1 + 2x_2 \leq 5 + M_1(1-y_1)
\]

Asignando un valor lo suficientemente grande a $M_1$, vale que si $y_1 = 1$ entonces la restricción $3x_1 + 2x_2 \leq 5$ se cumple. Notar que si $y_1 = 0$, la restricción no se aplica.

Esto permite expresar disyunciones de restricciones:
\[
\begin{array}{rl}
f(x_1, \ldots, x_n) & \leq b_1 + M_1(1-y_1) \\
& \vdots \\
f(x_1, \ldots, x_n) & \leq b_k + M_k(1-y_k) \\
\sum_{i=1}^{k} y_i & \geq 1
\end{array}
\]

\end{frame}

\begin{frame}
\frametitle{Ejemplo: Coloreo de grafos}

\begin{enumerate}

\item Variables binarias $x_ij$ si el nodo $i$ está pintado con el color $j$.

\item Variables binarias $w_j$ si el color $j$ está en uso.

\item Objetivo minimizar $\sum_{j=1}^{|C|} w_j$

\end{enumerate}

\end{frame}

\begin{frame}
\frametitle{Ejemplo: Coloreo de grafos (restricciones)}

\begin{enumerate}

\item Cada nodo debe tener un color:
\begin{itemize}
\item $\forall i \in V \exists j \in C : x_{ij} \wedge \forall j' \in C, j' \neq j : \neg x_{ij'}$
\item $\forall 1 \leq i \leq |V| : \sum_{j=1}^{|C|} x_{ij} = 1$
\end{itemize}

\item Colores distintos para nodos adyacentes:
\begin{itemize}
\item $\forall i,i' \in V : ady(i,i') \Rightarrow \forall j \in C : \neg (x_{ij} \wedge x_{i'j})$
\item $\forall 1 \leq i, i' \leq |V|, 1 \leq j \leq |C|, ady(i,i') : x_{ij} + x{i'j} \leq 1$
\end{itemize}

\item Un color está en uso si algún nodo está pintado con él:
\begin{itemize}
\item $\forall j \in C : \bigvee _{i \in V} x_{ij} \Rightarrow w_j$
\item $\forall 1 \leq i \leq |V|, 1 \leq j \leq |C| : x_{ij} \leq w_j$
\end{itemize}

\end{enumerate}

\end{frame}

\begin{frame}
\frametitle{MIPs}

Los problemas de 0-1 Integer Linear Programming como el anterior son casos particulares de los más genéricos Mixed Integer Programming, en los que algunas de las variables tienen la restricción de ser enteras y otras se mantienen continuas.

Consisten en minimizar o maximizar una función objetivo $cx$ sujeto a restricciones de la forma $Ax \leq b, x \geq 0$ con algunas variables $x_i$ enteras.

Estos problemas son uno de los pilares de la investigación operativa y permiten resolver de manera eficiente muchos problemas computacionalmente costosos.

\end{frame}


\subsection{Interpretación geométrica}

\begin{frame}
\frametitle{Interpretación geométrica}

En los problemas de programación lineal sobre continuos, se busca el óptimo sobre un politopo de cierta dimensión; dicho óptimo siempre coincide con un vértice del mismo, lo que lo hace un problema sencillo.

En programación lineal entera, las soluciones factibles son los puntos enteros contenidos en el politopo, que son generalmente exponenciales en la cantidad de restricciones y rara vez coinciden con los extremos.

\end{frame}

\begin{frame}
\frametitle{Cápsula convexa}

El mínimo politopo que contiene a todos los puntos enteros se denomina cápsula convexa.

Notar que el óptimo entero es un extremo del politopo, con lo que el problema puede reducirse a programación lineal continua (polinomial!) sobre dicho politopo.

El problema está en que la descripción de la cápsula convexa generalmente es exponencial.

\end{frame}

\subsection{Métodos de resolución}

\begin{frame}
\frametitle{Planos de corte}

Planos de corte se basa en refinar el poliedro mediante nuevas restricciones hasta que el óptimo entero sea un extremo del mismo.

Un \textit{plano de corte} es una restricción que mantiene todas las soluciones enteras del problema pero elimina algunas fraccionarias.

Lo ideal es generar planos de corte que sean \textit{facetas} de la cápsula convexa para acercarse al óptimo lo más rápido posible. 

\end{frame}

\begin{frame}
\frametitle{Algoritmo de planos de corte}

Algoritmo:

\begin{enumerate}
\item Resolver la relajacion del problema
\item Si no tiene solución o la solución es entera, fin
\item Si no, agregar planos de corte que eliminen el óptimo actual y repetir
\end{enumerate}

Dependiendo de los cortes usados, este algoritmo puede no terminar.
Computacionalmente, este algoritmo no arroja buenos resultados.

% Comentar simplex dual para obtener la nueva relajacion a partir del diccionario anterior

\end{frame}

\begin{frame}
\frametitle{Familias de planos de corte}

Existen familias de planos de corte que pueden aplicarse a cualquier problema:
\begin{enumerate}
\item Gomory-Chvátal
\item Clique
\item Cover
\item Disjunctive
\item Flow cover 
\item Flow path
\end{enumerate}

Generalmente los que mejor funcionan son planos de corte basados en cada problema en particular.

\end{frame}

\begin{frame}
\frametitle{Cortes de Gomory-Chvátal}

Los cortes de Gomory-Chvátal se basan en el redondeo de valores fraccionarios, usando el hecho de que las variables son enteras. Dado $Ax \leq b$, una combinación lineal de todas las restricciones usando un vector positivo $u$ resulta:
\[
\infer[\textit{Corte de GC}]
{(u^tA)x = \left\lfloor(u^tb)\right\rfloor}
{Ax \leq b, \ u \geq 0, \ (u^tA) \in \mathcal{Z}^n}
\]

Lo ideal es hallar $u$ tal que todos los $u a_j$ resulten enteros y no haya necesidad de truncar los lados izquierdos. Si ese es el caso se obtiene una faceta de la cápsula convexa.

El algoritmo de planos de corte usando esta familia siempre termina.

\end{frame}

\begin{frame}
\frametitle{Branch and bound}

El proceso de branch and bound consiste en una enumeración de todas las soluciones posibles del problema mediante un árbol, utilizando la técnica de divide and conquer. Puede verse como una instancia del esquema \textit{branch and infer}.

Dado un nodo original, se realiza el \textit{branching} sobre la solución de la relajación lineal dando lugar a distintos subproblemas; el óptimo del original es el mejor de todos los óptimos de los hijos.

Para prevenir la explosión combinatoria, se usan distintos criterios para cortar subárboles basados en cotas obtenidas en la solución de sistemas más sencillos (relajación lineal del problema).

\end{frame}

\begin{frame}
\frametitle{Branch and bound: Branching}

El branching clásico se realiza eligiendo una variable $x_k$ con valor fraccionario $v$ en la relajación lineal y abriendo dos nuevos subproblemas a partir de agregar las restricciones $x_k \leq \left\lceil v \right\rceil$ y $x_k \geq \left\lceil v \right\rceil$ al problema original. 

En el caso binario, esto equivale a asignar $x_k = 0$ y $x_k = 1$ a los hijos.

Una estrategia de branching implica definir en qué nodo y sobre qué variable(s) se realiza el branching (ej más fraccionaria, menos fraccionaria, random, menor índice) generando cuántos hijos.

\end{frame}

\begin{frame}
\frametitle{Branch and bound: Soluciones}

Si en un nodo la solución de la relajación resulta entera, no es necesario seguir explorando dicho subárbol. Dicha solución se marca como \textit{incumbent solution} si es mejor que cualquier otra hallada hasta el momento.

La incumbent solution es global y actúa como cota superior (en un problema de minimización) para el valor del óptimo.

Notar que si la relajación en un nodo no tiene solución, entonces es posible podar dicho subárbol.

\end{frame}

\begin{frame}
\frametitle{Branch and bound: Cotas}

Dado un problema de minimización, en cada nodo el valor del objetivo de la relajación representa una cota inferior del problema para ese subárbol.

Si la cota inferior es mayor que la incumbent solution en ese momento, entonces es posible podar todo el subárbol.

Esto hace que la estrategia de recorrido del árbol sea de suma importancia. Generalmente se usa el más nodo reciente por la facilidad de resolver la relajación a partir de una solución anterior usando simplex dual.

\end{frame}

\begin{frame}
\frametitle{Branch and bound: Heurísticas primales}

Una \textit{heurística primal} es una heurística por la cual se obtiene una solución del problema entero en un nodo a partir de la solución de la relajación lineal. 

Una heurística primal clásica consiste en redondear apropiadamente cada variable hacia el entero más próximo, con cuidado de no perder factibilidad.

Si bien puede que el resultado esté arbitrariamente lejos del óptimo, es una fuente de potenciales incumbent solutions que actúan como cotas superiores para las podas del árbol.

\end{frame}

\begin{frame}
\frametitle{Branch and cut}

El algoritmo de planos de corte, si bien no da buenos resultados al ser usado por sí solo, es computacionalmente muy eficiente usado en combinación con el branch and bound.

Se basa en aplicar la técnica de planos de corte en algunos nodos para generar así relajaciones más ajustadas que producen mayores cotas inferiores. Los cortes aplicados pueden ser tanto locales como globales.

Una estrategia para el branch and cut implica definir, además de los criterios de branching, la frecuencia e intensidad con la que se aplicarán los planos de corte en el árbol, así como qué familias de corte serán usadas.

\end{frame}

\subsection{Técnicas de preprocesamiento}
\begin{frame}
\frametitle{Preprocesamiento}

A partir de un análisis preliminar de las restricciones, es posible simplificar el modelo previo a su resolución.

\begin{itemize}
\item Ciertas variables (generalmente binarias) pueden asignarse un valor fijo.
\item Restricciones redundantes (una restricción es redundante si toda solución que verifica las demás restricciones la verifica) pueden eliminarse.
\item Algunas restricciones pueden ajustarse de manera de no perder soluciones enteras pero reduciendo el poliedro de la relajación.
\end{itemize}

\end{frame}

\begin{frame}
\frametitle{Fijado de variables}

Generalmente puede hacerse mediante un análisis de las variables binarias con mayor coeficiente, viendo que no es posible que tomen un determinado valor, con lo que se les asigna el opuesto.

\[
3x_1 + x_2 \leq 2 \Rightarrow x_1 = 0
\]

\[
4x_1 + x_2 - 2x_3 \geq 2 \Rightarrow x_1 = 1
\]

\end{frame}

\begin{frame}
\frametitle{Eliminación de restricciones redundantes}

Lo más sencillo es buscar restricciones en las que en ni aun \textit{mejor caso} es posible violarlas, usando las cotas de las variables involucradas.

Suponiendo las $x_i$ binarias, son redundantes:

\[
3x_1 + 2_x2 \leq 6
\]

\[
3x_1 - 2_x2 \geq -3
\]

\end{frame}

\begin{frame}
\frametitle{Ajuste de restricciones}

Usando las restricciones al dominio binario de las variables es posible ajustar las restricciones mediante métodos iterativos.

\[
2x_1 + 3x_2 \leq 4 \rightarrow x_1 + x_2 \leq 1
\]

Ver que el conjunto de soluciones en ambos casos es $(0,0), (1,0), (0,1)$.

\end{frame}

\section{Resolución generalizada}
\subsection{Cláusulas}
\begin{frame}
\frametitle{Cláusulas clásicas}

Sean $L_i$ literales, representables por variables binarias $x_i$ para los positivos y $1 - x_i$ para los negativos. Una cláusula clásica tiene la forma:
\[
L_1 + \ldots + L_m \geq 1
\]

Esto es equivalente a la disyunción de los $m$ literales. En proposicional se traduce como una cláusula de una fórmula en CNF.

\end{frame}

\begin{frame}
\frametitle{Cláusulas extendidas}

Una cláusula extendida tiene la forma:
\[
L_1 + \ldots + L_m \geq d
\]

Equivale a pedir que al menos $d$ de los $m$ literales se cumplan. Se requiere un número combinatorio en $m$ y $d$ de cláusulas clásicas para representar una extendida.

\end{frame}

\subsection{Esquema de inferencia}

\begin{frame}
\frametitle{Resolución generalizada}

Es posible definir un esquema de inferencia para resolución generalizada que opera sobre cláusulas extendidas.

\[
\infer[\textit{Implied clause}]
{L' \geq d'}
{L \geq d, \ |L - L'| \leq d - d'}
\]
\[
\infer[\textit{Resolución}]
{L + L' \geq 1}
{L_i + L \geq 1, \ \overline{L_i} + L \geq 1}
\]
\[
\infer[\textit{Suma diagonal}]
{\sum_{j=1}^m L_j \geq d+1}
{\bigwedge_{i=1}^{m} \sum_{j=1, j \neq i}^m L_j \geq d}
\]

\end{frame}

\subsection{Constraint Integer Programming}

\begin{frame}
\frametitle{CIPs}

El uso de técnicas de resolución lógica junto a métodos tradicionales de resolución de mixed integer problems está dando origen a un nuevo tipo de problemas denominado \textit{constraint integer problem} (CIP).

Estos problemas son un tipo de constraint problems en los que una vez fijadas las variables, el problema generado resulta lineal. Esto permite la aplicación de técnicas de ambos dominios a un mismo problema.

\end{frame}

\end{document}