%!TEX root = pcp.tex

\section{Branching strategies}
\label{subsec:resultsbranching}

We evaluated the different branching strategies described in section \ref{subsec:alg:branching} on regular graphs with fixed size and different density, in order to determine which reports the best results. We used a simple branch and bound algorithm bounded to 15 minutes of running time.

\subsection{Priorities}

The first test we implemented applied only priorities on the variables during the problem's initialization. Priorities were assigned according to the following formula:
\begin{equation*}
	prio(x_{ij}) = \alpha \delta_P(v_i) + \beta j
\end{equation*}

We tested with different values for $\alpha$ and $\beta$, both positive and negative, to generate different priorities. Although we found hardly any differences in higher density graphs, the ones with the lowest densities ($20\%$) did have significative differences.

In table \ref{table:branch:static} we report those $(\alpha,\beta)$ values which gave results better or near the ones obtained when not using priorities, this is, allowing \textsc{cplex} to choose automatically which variable to branch on.

\begin{table}[h]
\centering

\begin{tabular}{|c|c|c|}
\hline
\textbf{Priorities} & \textbf{Time} & \textbf{Gap} \\
\hline
$\alpha = 10$, $\beta = -1$ &  232.57 & 0.00 \\
$\alpha = 10$, $\beta = 1$ & 523.10 & 0.00 \\
cplex & 570.72 & 0.00 \\
\hline
 \end{tabular}

\caption{Gap and running time for branch and bound executions on $20\%$ density graphs with different priorities on the branching variables.}
\label{table:branch:static}

\end{table}	

Clearly giving the highest priority to nodes with the highest $\delta_P(v_i)$ value, tie-breaking in favor of higher color labels, is the best static branching priority.

\subsection{Dynamic strategies}

Having fixed the priorities to set on the variables, we use them as tie breaking strategies for the two devised strategies which depend on the variable's value (\ref{subsubsec:alg:branch:frac} and \ref{subsubsec:alg:branch:dsatur}). 

We set up a suite of graphs of different size and density to test most and less fractional strategies, as well as both degree of saturation strategies: branching on a particular $x_{ij}$ variable or creating one subproblem for each possible color for a particular node $v_i$. Results are displayed in table \ref{table:branch:dyn}; we report the resulting MIP gap, on which node that gap was obtained, and how many nodes were explored during the 15 minutes of execution.

\begin{sidewaystable}
\centering

\begin{tabular}{|c|ccc|ccc|ccc|ccc|ccc|ccc|}
\hline
\multicolumn{1}{|c|}{Graph} & \multicolumn{3}{|c|}{\textsc{dsatur-2}} & \multicolumn{3}{|c|}{\textsc{dsatur-(C+1)}} & \multicolumn{3}{|c|}{Less fractional} & \multicolumn{3}{|c|}{Most fractional} 
\\
 & gap & found & nodes & gap & found & nodes & gap & found & nodes & gap & found & nodes
\\
\hline
EW 20\% N=90 & \b{0.17} & 77 & 94 & \b{0.17} & \b{76} & 95 & 0.25 & 177 & 250 & 0.25 & 134 & 178 
\\
EW 40\% N=100 & \b{0.33} & 20 & 24 & \b{0.33} & \b{14} & 24 & 0.39 & 27 & 39 & 0.33 & 30 & 44 
\\
EW 60\% N=80 & 0.37 & \b{7} & 18 & 0.37 & 18 & 19 & 0.37 & 30 & 32 & 0.37 & 23 & 27 
\\
EW 80\% N=100 & 0.42 & 2 & 2 & 0.42 & \b{1} & 3 & 0.44 & 3 & 4 & 0.42 & 4 & 4
\\
\hline 
 \end{tabular}

\caption{Results for fractional and degree of saturation (spanning either $2$ or $C+1$ subproblems) branching strategies on branch and bound schemes. Data reported is MIP gap after $15$ minutes of execution, on which node (in thousands) that gap was found, and how many nodes (in thousands) were explored in total.}
\label{table:branch:dyn}

\end{sidewaystable}

Within fractional strategies, branching on the \textit{most fractional} variable generates the best results, although there is little difference with the \textit{less fractional} criteria. There is a significative difference, mostly in low-density graphs, between fractional and degree of saturation strategies. Whereas the former requires less computational time to execute and allows the algorithm to explore a larger number of nodes, the latter obtains a much smaller gap much earlier in the exploration.

We will be using degree of saturation criteria, and test its both alternatives in conjunction with a custom primal heuristic to determine the best branching and primal configuration for the problem.

However, the obtained gaps were better using fixed priorities on the variables than using either dynamic strategy. We may infer that the overhead generated by overriding the engine's default behavior, and the computational effort required iterating all the variables, cause the custom strategies to behave poorer than the fixed priorities. We will compare them again once we add the custom primal heuristic in section \ref{subsec:resultsprimal}.

\subsection{Implied bounds}

As explained in section \ref{subsubsec:alg:branch:bounds}, whenever we fix a variable $x_{i^*j^*}$ to $1$ when branching, we have the possibility of fixing the value of other variables due to logical implications:
\begin{itemize}
\item Fix all other variables in the partition to zero, as only one node must be painted within the partition.
\[
x_{ij} = 0 \quad \forall i \in P(i^*),\ \forall j \in C,\ i \neq i^* \vee j \neq j^*
\]
\item Fix all variables corresponding to adjacent nodes with same color to zero, due to color conflict restrictions.
\[
x_{ij^*} = 0 \quad \forall i \in N(i^*)
\]
\item Fix all color variables $w_j$ to $1$ for all labels less or equal than the current lower bound $\chi_{LB}$ on the chromatic number.
\[
w_j = 1 \quad \forall j \leq \ceil{\chi_{LB}}
\] 
\end{itemize}

We re-ran the previous test with the \textsc{dsatur-2} configuration, with and without these bounds, to check if the overhead generated by forcing multiple bounds on each branching is compensated by the reduction in the branch-and-bound tree. Table \ref{table:branch:bounds} reflects the average gaps for different bounds set.

\begin{table}[h]
\centering

\begin{tabular}{|c|c|c|}
\hline
$x_{ij}$ bounds & $w_j$ bounds & gap \\
\hline
On & On & 0.3225 \\
On & Off & 0.4225 \\
Off & On & 0.4225 \\
Off & Off & 0.4225 \\
\hline
\end{tabular}

\caption{Gaps on branch-and-bound executions for different bounds set during branching, using \textsc{dsatur-2} branching strategy.}
\label{table:branch:bounds}

\end{table}	

Applying all bounds during the process clearly reports the best results. The total number of nodes generated during the process was similar between all the configurations, so the implied bounds do not generate a noticeable overhead. 

Therefore, we will be applying all bounds for both $x_{ij}$ and $w_j$ variables for all upcoming tests.
