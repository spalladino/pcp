\begin{otherlanguage}{spanish}
\renewcommand{\abstractname}{Resumen Extendido}
\begin{abstract}

Una red óptica de tipo WDM (Wavelength Division Multiplexing, o multicanalización por división de longitud de onda) permite la transmisión simultánea de distintos paquetes de datos a través de una misma fibra utilizando distintas longitudes de onda dentro de la misma. 

La conexión punto a punto entre dos nodos de la red se denomina, en estos casos, lightpath (camino óptico). Si bien en estas redes existen tipos de nodos más avanzados con la capacidad de modificar la longitud de onda usada por un lightpath durante su recorrido, a efectos del problema nos concentraremos en la versión más sencilla en la que el lightpath utiliza la misma longitud en todo su recorrido, imponiendo lo que se denomina la wavelength continuity constraint (restricción de continuidad de longitud de onda).

Dado un segmento de fibra, no puede ocurrir que dos lightpaths distintos intenten transmitir en la misma longitud de onda, o habrá colisión entre los datos enviados. Esto impone la denominada wavelength clash constraint (restricción de conflicto de longitud de onda), lo que sumado a la anterior lleva a que dos lightpaths distintos no pueden tener la misma longitud de onda si comparten algún segmento de fibra óptica.

A partir de estas restricciones se genera el problema de RWA (Routing and Wavelength Assignment, o ruteo y asignación de longitudes de onda), que consiste en, dado un conjunto de conexiones a satisfacer, determinar los enlaces a utilizar y longitud de onda para cada uno de los caminos ópticos.

Si bien existe una gran cantidad de soluciones para el problema anterior, se busca alguna que sea óptima en un determinado criterio. En este caso nos enfocamos en minimizar la cantidad de longitudes de onda requeridas para satisfacer las conexiones, lo cual permite utilizar fibras de menor costo al tener que soportar una menor cantidad de longitudes de onda distintas por enlace. Este problema es el denominado min-RWA.

El RWA suele ser atacado bajo dos enfoques: o bien como un único problema en el que se busca resolver simultáneamente el ruteo y la asignación de longitudes de onda, o bien como un problema de dos etapas en las que se separan dichas fases. Es esta última opción en la que nos concentramos en este trabajo. 

En trabajos como \cite{hyytia14wavelength} y \cite{manohar2002routing} se buscan primero los caminos a utilizar para el ruteo, utilizando criterios de camino mínimo o edge disjoint path respectivamente, para luego resolver la asignación de longitudes de onda mediante un problema de coloreo de grafos.

El problema de coloreo de grafos, extensamente estudiado en la literatura, consiste en asignar un color a cada nodo de un grafo con la restricción de que dos nodos adyacentes no tengan el mismo color, con el objetivo de utilizar la menor cantidad de colores distintos como sea posible. Modelando cada lightpath como un nodo, y conectando dos nodos si corresponden a lightpaths que comparten al menos un segmento de fibra óptica, es posible resolver el problema de asignación de manera óptima.

Li y Simha, por otra parte, proponen en \cite{Li00thepartition} generar un conjunto de caminos candidatos para cada conexión en la primera fase. Es decir, la etapa de ruteo no genera un lightpath por cada pedido de conexión, sino varios, todos ellos posibles candidatos. Esto implica que en la segunda etapa se derive una instancia del problema de coloreo particionado, cuya resolución es el principal objetivo de trabajo.

El problema de coloreo particionado toma un grafo en el que el conjunto de nodos se encuentra particionado, y tiene por objetivo asignar un color a un solo nodo de cada partición, de manera que se mantenga la restricción de que dos nodos adyacentes tengan distinto color y se minimice la cantidad de colores distintos usada. Es fácil notar que este problema es una generalización del problema de coloreo de grafos tradicional, ya demostrado por Karp en \cite{karp2010reducibility} que es NP-Completo, lo que implica que su resolución de manera exacta requiere un tiempo de procesamiento exponencial en el tamaño del grafo de entrada.

Considerando cada lightpath posible como un nodo, agrupados en una misma partición si satisfacen el mismo pedido de conexión punto a punto, es posible resolver el problema de asignación utilizando la menor cantidad de longitudes de onda posibles para los candidatos propuestos. El manejar conjuntos de lightpaths para la fase de asignación, en lugar de un solo lightpath por conexión, permite llegar a una mejor solución para el problema.

Buena parte del trabajo sobre resolución del problema de coloreo particionado (PCP) es heurístico. Solamente en \cite{frota2010branch}, Frota et al presentan un algoritmo de branch and cut para su resolución de manera exacta, basándose en un modelo de programación lineal entera, generalizado a partir del modelo de coloreo por representantes, desarrollado en \cite{campelo2008asymmetric} y \cite{campelo2004cliques}.

La programación lineal entera es una técnica usada frecuentemente para atacar la resolución exacta de problemas de optimización combinatoria, en los que una exploración exhaustiva de las diferentes soluciones en busca del óptimo se vuelve impracticable debido a la explosión exponencial ocurrida al enumerar dichas soluciones. Se suelen utilizar algoritmos de planos de corte, de branch and bound o una combinación de ambos, como ser cut and branch o branch and cut.

En este trabajo fue desarrollado un algoritmo de branch and cut para resolver el problema de forma exacta, utilizando un modelo de programación lineal entera basado en el desarrollado para el problema de coloreo tradicional por Méndez-Díaz y Zabala en \cite{mendez2006branch}. La elaboración de un algoritmo de branch and cut específico para un determinado problema requirió el desarrollo de los siguientes componentes:

\begin{itemize}
\item	La formulación de un modelo lineal entero para el problema. Distintas variantes generalizadas a partir del modelo de coloreo tradicional, incluyendo restricciones de eliminación de simetría, entre otras, fueron evaluadas sobre distintas instancias del problema hasta arribar a una formulación definitiva.
\item	La búsqueda de desigualdades válidas para el modelo elegido. Una vez determinado el modelo, se buscan desigualdades satisfechas por toda solución entera del modelo pero no así por las fraccionarias. Esto permite luego aplicar dichas desigualdades eliminando los puntos fraccionarios, derivando en un algoritmo de planos de corte. Generalizando desde las familias conocidas para coloreo tradicional, hallamos seis familias distintas de desigualdades válidas.
\item	La implementación de heurísticas de separación para las desigualdades válidas halladas. Dada una solución fraccionaria, se debe hallar una desigualdad válida de alguna de las familias desarrolladas que sea violada por dicha solución, de manera de agregarla al modelo de la relajación y moverse a otra solución. Se implementaron heurísticas para cada una de las familias encontradas.
\item	Una heurística inicial para obtener rápidamente una solución inicial aceptable para el algoritmo de branch and cut. Esto permite reducir notablemente el tamaño del modelo sobre el cual se trabaja. Como heurística inicial se evaluaron distintas alternativas, hasta optar por una variante para coloreo particionado del algoritmo DSATUR \cite{brelaz1979new} que desarrollamos. Este algoritmo es de enumeración implícita, con lo que genera una solución exacta dado el suficiente tiempo, pero tiene la particularidad de hallar buenas soluciones con poco tiempo de ejecución, lo que lo hace un excelente candidato como heurística, interrumpiendo su ejecución luego de determinado tiempo.
\item	Una heurística primal para derivar soluciones enteras intermedias a partir de las soluciones de las relajaciones obtenidas a lo largo del árbol de branching. Para esto reutilizamos la heurística inicial, modificándola de manera tal que reaprovechase la información provista por la solución de la relajación en su exploración del conjunto de soluciones.
\item	Una estrategia para generación del árbol de branching. En cada nodo, debe determinarse cuántos nodos hijos se abren y con qué criterio. Si bien se suele forzar una variable binaria con valor fraccionario a cero y a uno en cada hijo, hay otras alternativas posibles. Luego de evaluar distintas estrategias, optamos por una que fuerza no solo una determinada variable sino todas las demás implicadas lógicamente; además de establecer un criterio de selección de dicha variable en función de su grado de saturación y valor fraccional.
\item	Una estrategia para el recorrido y poda del árbol. Evaluamos opciones clásicas como DFS, BFS o best bound sobre distintas instancias hasta determinar cuál se comportaba mejor dentro de nuestro esquema de branch and cut dependiendo de la densidad del grafo. Asimismo efectuamos una poda del árbol de enumeración una vez alcanzada altura suficiente, ejecutando una corrida exhaustiva de DSATUR, la cual ejecuta a una mayor velocidad que el branch and cut una vez fijada la suficiente cantidad de colores.
\end{itemize}

Todos estos componentes fueron implementados y sus distintas variantes evaluadas sobre múltiples instancias. La implementación fue realizada en Java utilizando como framework CPLEX 12. 

La versión final del algoritmo fue evaluada contra los motor de mixed integer programming search y dynamic search de CPLEX 12 sin realizar modificaciones sobre la configuración original, y se verificó que el algoritmo desarrollado para PCP obtiene mejores gaps y tiempos, con lo que los componentes desarrollados efectivamente favorecen la resolución del problema. Asimismo evaluamos el rendimiento del algoritmo contra el reportado por el branch and cut basado en el modelo de representantes \cite{frota2010branch}.

\end{abstract}
\end{otherlanguage}